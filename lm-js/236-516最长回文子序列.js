/*
647. 回文子串
给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

 

示例 1：

输入："abc"
输出：3
解释：三个回文子串: "a", "b", "c"
示例 2：

输入："aaa"
输出：6
解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"
 

提示：

输入的字符串长度不会超过 1000 。

*/

/*
    思路：这次把状态转移方程给摸索出来了。
        但是遍历顺序我没弄出来，i,j的初始值，递增还是递减，这个逻辑不知道从哪开始思考。
        1.dp数组的意义
        dp[i][j]字符串s从i~j最长回文子串的长度
        2.状态转移方程
        if(s[i]==s[j]){
            //加这两个字符，即长度加2
            dp[i][j]=dp[i+1][j-1]+2
        }
        else{
            //不同时，看头缩进还是尾缩进
            dp[i][j]=Math.max(dp[i+1][j],dp[i][j-1])
        }
        3.遍历顺序
        先dp[i+1][j-1]才有dp[i][j]
        说明i需要递减，j需要递加。
        i很简单，就从len-1开始递减至0即可。
        那么j要知道从dp[i+1][j],dp[i][j-1],dp[i+1][j]，最小的尾地址为j-1,那么肯定不能从0开始，需要从len出发，慢慢去发散
        既要递增又要len开始,同时还必须是两个不同的字符对比。不然长度+2不符合状态转移方程.因此j的初始值为i+1.递增遍历至<=len-1
        4.初始化
        dp[i][i]=1，同一个字符是回文子序列。
        5.举例


*/


var longestPalindromeSubseq = function(s) {
    let len=s.length
    let dp=Array.from(Array(len),()=>Array(len).fill(0))
    for(let i=len-1;i>=0;i--){
        dp[i][i]=1
        for(let j=i+1;j<len;j++){
            if(s[i]==s[j]){
                dp[i][j]=dp[i+1][j-1]+2
            }
            else{
                dp[i][j]=Math.max(dp[i+1][j],dp[i][j-1])
            }
        }
    }
    return dp[0][len-1]
};

/*
    时间复杂度：O(N^2)
    空间复杂度：O(N^2)
*/

/*
    思考：这一周的题可以明显感觉到，两个字符串比一个字符串要好思考一些，结构也会更清晰一些。
    动态规划还是有进步的：从网格模型----->两个字符串或数组模型---->一个字符串模型
*/