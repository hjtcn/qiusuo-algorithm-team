1. Clearfication:
   n = 3 
    二叉搜索树的种数？
    返回满足题意的二叉搜索树的种数
    怎么思考这种题目呢？
        目前发现没有思路哈
    换一种思路呢？
    3
    1 2 3 

2. 看题解：
G(n): 长度为n的序列能构成的不同二叉搜索树的个数
 F(i,n): 以i为根、序列长度为n的不同二叉搜索树的个数
不同的二叉搜索树的总数G(n),是对遍历所有i(i >= 1 && i <=n)的F(i,n)之和
对于边界情况，当序列长度为1或0时，只有一种情况：
G(0)=1,G(1) = 1
哇：
数学公式
感觉公式还是蛮难推导的

func numTrees(n int) int {
    G := make([]int, n + 1)
    G[0], G[1] = 1, 1
    for i := 2; i <= n; i++ {
        for j := 1; j <= i; j++ {
            G[i] += G[j-1] * G[i-j]
        }
    }
    return G[n]
}

3. 复杂度分析：
时间复杂度：O(n*n)
空间复杂度：O(n)

4. 总结：
用公式法分解子问题还是蛮科学的，慢慢看，实在学习思路和分析问题的能力
