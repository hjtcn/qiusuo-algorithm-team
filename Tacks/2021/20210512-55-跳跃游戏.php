<?php
 /*
 * @Descripttion: 周一的
 * @Author: tacks321@qq.com
 * @Date: 2021-05-12 16:11:13
 * @LastEditTime: 2021-06-25 17:53:43
 */

/*
 * @lc app=leetcode.cn id=55 lang=php
 *
 * [55] 跳跃游戏
 *
 * https://leetcode-cn.com/problems/jump-game/description/
 *
 * algorithms
 * Medium (41.54%)
 * Likes:    1184
 * Dislikes: 0
 * Total Accepted:    233.9K
 * Total Submissions: 555.5K
 * Testcase Example:  '[2,3,1,1,4]'
 *
 * 给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。
 * 
 * 数组中的每个元素代表你在该位置可以跳跃的最大长度。
 * 
 * 判断你是否能够到达最后一个下标。
 * 
 * 
 * 
 * 示例 1：
 * 
 * 
 * 输入：nums = [2,3,1,1,4]
 * 输出：true
 * 解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
 * 
 * 
 * 示例 2：
 * 
 * 
 * 输入：nums = [3,2,1,0,4]
 * 输出：false
 * 解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
 * 
 * 
 * 
 * 
 * 提示：
 * 
 * 
 * 1 
 * 0 
 * 
 * 
 */

// @lc code=start

/**
 * 【1】正向贪心
 *
 * 执行用时：172 ms, 在所有 PHP 提交中击败了11.48%的用户
 * 内存消耗：16.6 MB, 在所有 PHP 提交中击败了91.80%的用户
 * @date  2021-05-31 18:26:18
 */

class Solution1 {
    /**
     * @param Integer[] $nums
     * @return Boolean
     */
    function canJump($nums) {
        $len = count($nums);
        if($len <= 0) {
            return false;
        }
        
        // 边界判断
        if($len == 1) {
            return true;
        }
        
        // 此处代码，PHP是可以优化整个程序的，因为如果没有0，也不需要遍历判断
        // 用时减少 4ms
        // 如果不存在0 ，则一定可达
        if(!in_array(0, $nums)) {
            return true;
        }

        // 最远可到达的位置
        $maxpos = 0;

        // 贪心遍历
        for ($i=0; $i < $len; $i++) { 
            // 当前的位置 小于等于 最大可以跳跃的位置，表示可以向后跳
            if($i <= $maxpos) {
                # 对每一个状态选择都做局部最优解
                $maxpos = max($maxpos, $i+$nums[$i]);

                // 如果最大可跳跃的距离足够大，肯定可以跳到最后
                if($maxpos >= $len - 1) {
                    return true;
                }
            } else {
                // 说明当前位置 i 不在当前能够到达的最大位置中，则无法跳到最后直接返回 false 即可。
                return false;
            }
        }

        // 遍历结束，最远的位置还是 不能到最后，则失败
        return false;
        
    }

}



/**
 * 【2】逆向贪心
 *
 * 执行用时：168 ms, 在所有 PHP 提交中击败了14.75%的用户
 * 内存消耗：16.5 MB, 在所有 PHP 提交中击败了98.36%的用户
 * @date  2021-05-31 18:26:18
 */
class Solution2 {

    /**
     * @param Integer[] $nums
     * @return Boolean
     */
    // 从后向前贪心
 
    function canJump($nums) {
        $len = count($nums);
        if($len <= 0) {
            return false;
        }
        
        // 边界判断
        if($len == 1) {
            return true;
        }
        
        // 最后的位置
        $endpos = $len - 1;
        for ($i=$endpos; $i>=0; $i--) { 
            // 第 i 个位置可以到达 最后
            if($i + $nums[$i] >= $endpos) {
                // 如果倒数第二个可以，那么就下一次判断是否倒数第二个可以跳到最后
                $endpos = $i;
            }
        }
        // 判断最后是否遍历到 0 ，如果是则正确
        return $endpos == 0;

    }

}



/*
【题目】

问题是否能到达最后一个位置？

    我没有从算法角度先入手，而是从一个题目的答案入手，反复找出问题的关键点，挖掘潜在信息。
        1、最后一个数字是0，有无影响？
            如果我们能够到达最后一个位置，那么至于最后一个位置上的数字便没有意义。
        2、为什么到达不到最后一个位置？
            通过题意，我们看到有0的存在，也就是走不下去啦。
        3、是不是只要有0，就走不下去？  
            也不是这样，比如[2, 0, 1, 1] ，因为我们可以第一步的时候就跨过去。所以遇到0，只要前面有可以跨越的即可
        4、是不是没有0，一定可以走下去？
            是这样的，目前我没有找到反例，也就是说，只要足够大的步数，足够你跳到最后啦。
        5、数组中有无负数，需要后退那种？
            没有，题目给的非负整数数组，也就是只有0和正数。
    虽然上述的问题，并不会带来什么思路
【方法】
    一些各种各样的思路

1、贪心

    这个题也是因为见到过，所以记住是用贪心的思路，而且事件复杂度也比较低。官方题解就不错
    https://leetcode-cn.com/problems/jump-game/solution/tiao-yue-you-xi-by-leetcode-solution/

    1.1 从前向后贪心
    1.2 从后向前贪心


2、判断0的位置是否可以跨越？

    也就是当遇到0的时候，再去回头依次遍历，看看是否有可以跨域的0的位置，这个思路可以，但是时间复杂度高
        https://leetcode-cn.com/problems/jump-game/solution/tiao-yue-you-xi-by-sunxuejian-hf6s/
    
3、递归

【解析】

1、贪心
    对问题的求解是局部上的最优解！
    对贪心策略的选取！
    不影响后续的决策影响！
    
    也就是有点俄罗斯套娃，从内而外的解决问题。
    对当前的子问题进行最优解，那么包含子问题的下一个子问题也会是最优解，从而堆叠到全局的最优解。
    

    官方的思路，在我看来还是比较好理解，而且复杂度低
        
        （1）对于数组中的位置，如何判断是否可达？
            对于某个位置 y是否可达
                当前位置是 x , 其本身可以到达，那么最大可以跳跃 x + nums[x] 距离
                也就是当 x + nums[x] >= y ，那么 y位置可达
            
        （2）如果可以跳跃的位置足够大，大于等于数组最后一个位置，则返回true
        
        

        遍历整个数组
            每次更新最远可以跳到的位置，并标记 x + nums[x]
            如果 最远可以到达的位置 大于等于数组中的最后一个位置
                那就说明最后一个位置可达，我们就可以直接返回 true
        如果 遍历结束
            最后一个位置还不行，那么就返回 false

        时间复杂度：O(n) 
        空间复杂度：O(1) 

     



【总结】
1、实际上看到原题，我还是忍不住要看以前的代码思路，反而不是把他当成一个新题，去一步步思考。这样有点限制自我，是一种背题的感觉。    
2、贪心，从后向前遍历效率更高一些？
3、


*/