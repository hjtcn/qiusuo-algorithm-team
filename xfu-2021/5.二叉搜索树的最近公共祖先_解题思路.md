# 剑指 Offer 68 - I. 二叉搜索树的最近公共祖先
> LeetCode地址：[访问](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/) <br/>
> Github地址：[访问](/)

## 题目及题意分析

### 题目
给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

例如，给定如下二叉搜索树:  root =[6,2,8,0,4,7,9,null,null,3,5]

![image](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png)

说明:

所有节点的值都是唯一的。
p、q 为不同节点且均存在于给定的二叉搜索树中。


**示例：**

```
示例 1:

输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6 
解释: 节点 2 和节点 8 的最近公共祖先是 6。
示例 2:

输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
输出: 2
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。

```

### 题意

- 找到指定的结点
- 判断指定的结点的父结点
    - 给定的也可能是父结点

### 解题思路

**逻辑梳理**

1. 递归结点树
2. 判断当前结点的值在不在p、q中
    - 不在，判断左结点的值是不是p或q
        - 不是，结束
        - 是，继续判断右结点的值是不是另外一个值（应该可以不用判断，若题目给定的条件一定成立，那么父节点不匹配，左结点匹配，右结点就一定匹配）
            - 是， 【返回】父节点的值
            - 不是，（条件应该不成立）
    - 在，判断左右结点值满不满足另外一个（按照题意，数字唯一，那么父节点只要存在p、q中，有一个结点必定是另外一个，否则没有答案）
        - 满足，返回结点的值
        - 不满足，（条件不成立）
 
**问题**

没有理解好题意，题目说的是【最近】的【公共】祖先，不一定是子结点。


**解决**

通过查看题解，发现自己的思考有所偏差，根据题目条件【二叉搜索树】，就应该使用搜索树性质，搜索树中左子树的所有值一定小于当前结点的值，右子树中的所有值一定大于当前结点的值。
因此只需要判断当前结点和p、q的关系就可以判断出结果

 
**逻辑重新梳理**

1.当前结点的值均大于p、q的值，递归从左子树中找
2.当前结点的值均小于p、q的值，递归从右子树中找
3.当前结点值在p、q值的中间，结束就是这个结点的值


## 代码实现

**失败代码1**

```
/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */
function lowestCommonAncestor(root: TreeNode | null, p: TreeNode | null, q: TreeNode | null): TreeNode | null {

	if(root){
        const mVal = root.val;
        const leftNode = root.left;
        const rightNode = root.right;
        const pVal = p ? p.val : null;
        const qVal = q ? q.val : null;

        if(mVal === pVal || mVal === qVal) {
            return root;
        }else{
            const leftTrue = leftNode && (leftNode.val === pVal || leftNode.val === qVal);
            const rightTrue = rightNode && (rightNode.val === pVal || rightNode.val === qVal);
            if(leftTrue && rightTrue){
                return root;
            }
        }

        return lowestCommonAncestor(leftNode, p, q) || lowestCommonAncestor(rightNode, p, q);

    }
};
```


```
// 输入
[3,1,4,null,2]
2
4
// 输出
2
// 预期结果
3
```
分析：没有深入结点进行判断，只判断了相邻子结点

**正确代码**

```
/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */
function lowestCommonAncestor(root: TreeNode | null, p: TreeNode | null, q: TreeNode | null): TreeNode | null {

	if(root){
        const mVal = root.val;
        const pVal = p ? p.val : null;
        const qVal = q ? q.val : null;
        if(mVal > pVal && mVal > qVal) return lowestCommonAncestor(root.left, p, q);
        if(mVal < pVal && mVal < qVal) return lowestCommonAncestor(root.right, p, q)
    }

    return root;
};
```
## 总结：
对题目的分析能力还需要提升，基本数据结构的概念还需要加深一下，拿到题目还是需要多思考才可以。