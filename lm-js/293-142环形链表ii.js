/*
142. 环形链表 II
给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。

不允许修改 链表。

 

示例 1：



输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
示例 2：



输入：head = [1,2], pos = 0
输出：返回索引为 0 的链表节点
解释：链表中有一个环，其尾部连接到第一个节点。
示例 3：



输入：head = [1], pos = -1
输出：返回 null
解释：链表中没有环。
 

提示：

链表中节点的数目范围在范围 [0, 104] 内
-105 <= Node.val <= 105
pos 的值为 -1 或者链表中的一个有效索引
 

进阶：你是否可以使用 O(1) 空间解决此题？
*/

/*
    题解：这个使用假设推断法。
         写写画画，有三个重要节点：
         1.出发点
         2.入口(即目标)
         3.相遇节点
         也可以换乘三段路程
         slow节点从起始位置到入口为x
         slow节点从入口到相遇节点为y
         fast节点从相遇节点到入口为z
         根据追赶的路径可以得出2*(x+y)=(y+z)*n+x+y
         调整可得x+y=(y+z)*n,目标要求x,则x=(y+z)*n-y
         提出y+z,则x=(y+z)*(n-1)+z
         n肯定不小于1，跑过1圈才追上。以最小情况推断
         当n等于1时，x=z.

         此时将公式对准题意本身。取两个节点开始跑。一个从出发点跑，一个从相遇点跑。每次跑一步。则相遇的时候就是入口点。

         坑：注意细节，边界值判断。
*/


var detectCycle = function (head) {
    if (!head) return head
    let slow = head, fast = head, target = head
    //标记，是否出现环了(即第一次快慢指针是否追上了)
    let flag = 0
    while (fast && fast.next) {
        fast = fast.next.next
        slow = slow.next
        if (slow == fast) {
            flag = 1
            break;
        }
    }
    if (flag == 1) {
        while (target != fast) {
            target = target.next
            fast = fast.next
        }
        return target
    }
    return null
};

/*
    时间复杂度：O(N)
    空间复杂度：O(1)
*/

/*
    思考：敢于推断，特殊值如果一定成立，就可以想方法去带入
*/