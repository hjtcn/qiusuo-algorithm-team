给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。
设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:
你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
示例:
输入: [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]

    1. Clarfication:
    状态变化：
    动态规划五部曲：
    1. dp定义：
        dp[i][j] ； 表示，第i天的在j的状态下的利润
        第i天什么操作都没有： dp[i][0]: dp[i - 1][0]
        第i天买入：可以是前一天冷冻，这一天买入，也可能是前一天什么都没做买入 也可以是前一天dp[i][1] = max(dp[i-1][3] - prices[i],dp[i-1][0] - prices[i])
        第i天卖出: dp[i][2] = dp[i-1][1] + prices[i]
        第i天冷冻: dp[i][3] = max(dp[i-1][2],dp[i-1][0],dp[i - 1][1])
    2. 动态规划方程：
        dp[i][0] = dp[i-1][0]
        dp[i][1] = max(dp[i-1][3] - prices[i], dp[i-1][0] - prices[i])
        dp[i][2] = dp[i-1][1] + prices[i]
        dp[i][3] = max(dp[i-1][2],dp[i-1][0],dp[i-1][1])
    3. 初始化：
         第0天什么都没做：dp[i][0] = 0
         第0天买入: dp[i][1] = -prices[i]
         第0天卖出：dp[i][2] = 0
         第0天冷冻  dp[i][3] = 0 
模拟写的代码，上面的状态没有分析清楚

func maxProfit(prices []int) int {
    n := len(prices)
    if n <= 0 {
        return 0
    }
    dp := make([][]int, n)
    for i := 0;i < n;i++ {
        dp[i] = make([]int, 4)
    }
    dp[0][1] = -prices[0]
    for i := 1;i < n;i++ {
        dp[i][1] = max(dp[i - 1][3] - prices[i],dp[i-1][0] - prices[i])
        // 我第2天买了不一定非要卖出去，所以状态没有表示出来
        dp[i][2] = max(dp[i-1][1] + prices[i],dp[i][]
        dp[i][3] = max(max(dp[i-1][2],dp[i-1][0]),dp[i-1][3])
    }
    
    return max(dp[n-1][2],dp[n-1][3])
}
                       
func max(x,y int) int {
    if x > y {
        return x
    }
    return y
}

2. 看题解：
func maxProfit(prices []int) int {
    if len(prices) == 0 {
        return 0
    }
    n := len(prices)
    // f[i][0]: 手上持有股票的最大收益
    // f[i][1]: 手上不持有股票，并且处于冷冻期中的累计最大收益
    // f[i][2]: 手上不持有股票，并且不在冷冻期中的累计最大收益
    f := make([][3]int, n)
    f[0][0] = -prices[0]
    for i := 1; i < n; i++ {
        f[i][0] = max(f[i-1][0], f[i-1][2] - prices[i])
        f[i][1] = f[i-1][0] + prices[i]
        f[i][2] = max(f[i-1][1], f[i-1][2]) 
    }
    return max(f[n-1][1], f[n-1][2])
}

func max(x, y int) int {
    if x > y {
        return x
    }
    return y
}

我们目前持有一支股票，对应的「累计最大收益」记为 f[i][0]
我们目前不持有任何股票，并且处于冷冻期中，对应的「累计最大收益」记为 f[i][1]
我们目前不持有任何股票，并且不处于冷冻期中，对应的「累计最大收益」记为 f[i][2]

dp[i][0] 持有股票：
目前持有的股票可以是在第 i - 1天就已经持有的，或者是第i天买入的，那么第i - 1天就不能持有股票并且不能处于冷冻期

dp[i][1] 处于冷冻期：
第i天结束之后处于冷冻期的原因是在当天卖出了股票，那么说明在第i-1天我们必须持有一只股票然后卖掉

f[i][1] = f[i-1][0] + prices[i]
dp[i][2] 我们在第i天结束后，不持有股票并且不处于冷冻期，即第i-1天时不持有股票，如果处于冷冻期，对应的状态为f[i-1][1]

3. 复杂度分析：
时间复杂度：O（n)
空间复杂度：O（n)

4. 总结
4.1：这道题一开始的转化状态没有分析清楚，所有后面写的代码也是乱掉的了
4.2:  提前把问题分析和理解清楚是很重要很重要的一部分
