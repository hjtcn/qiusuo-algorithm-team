// 70. 爬楼梯
// 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

// 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

// 注意：给定 n 是一个正整数。

// 示例 1：

// 输入： 2
// 输出： 2
// 解释： 有两种方法可以爬到楼顶。
// 1.  1 阶 + 1 阶
// 2.  2 阶
// 示例 2：

// 输入： 3
// 输出： 3
// 解释： 有三种方法可以爬到楼顶。
// 1.  1 阶 + 1 阶 + 1 阶
// 2.  1 阶 + 2 阶
// 3.  2 阶 + 1 阶

/**
 * 感觉自己的分析问题能力太弱了，可能是基础太薄弱了，还需要提高
 * 学习了题解中的讲解文章，自己捋了一下，将题解的BFS改成了DFS，感觉DFS还是很简洁的
 */

// ============================================================
// ===                                                      ===
// ===      状态：通过,执行用时: 80 ms,内存消耗: 40.1 MB     ===
// ============================================================

function climbStairs(n: number): number {
    let count = 1;

    // num1是上上次的结果，num2是上一次的结果，n是遍历次数
    function go(num1: number, num2: number, n:number){
        // 限制遍历次数：从n-1开始减到0为止
        if(n){
            count = num1 + num2; // 当前的结果是上一次和上上此结果的合
            go(num2, count, n-1);// 将遍历的结果匹配到对应位置
        }
    }

    go(1, 1, n-1);

    return count;
    
};


/**
 * 1.从这道题更加看出自己的基础太薄弱了，这周要把算法书读一读
 * 2.这道题应该是以前做过的题，但是自己已经全忘了:-(
 * 3.虽然下面的方法是错误的解法，但是我觉得思路也没有问题（不过这种思考方式之后应该要避免一下，感觉完全没有分析到点上）
 */


// ============================================================
// ===                                                      ===
// ===                        超时                          ===
// ============================================================

function climbStairs1(n: number): number {
    let count = 0;

    function go(num: number, step: 1 | 2){
        num += step
        if(num >= n){
            count++;
            return;
        }

        go(num, 1);
        go(num, 2);
    }

    go(0, 1);

    return count;
    
};