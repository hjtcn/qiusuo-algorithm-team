给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。

你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。

示例 1:

输入: 
	Tree 1                     Tree 2                  
          1                         2                             
         / \                       / \                            
        3   2                     1   3                        
       /                           \   \                      
      5                             4   7                  
输出: 
合并后的树:
	     3
	    / \
	   4   5
	  / \   \ 
	 5   4   7
注意: 合并必须从两个树的根节点开始。

1.Clarificaion:
 合并二叉树：
 Q: 返回的时候需要新建节点，还是直接合并到节点1 上面呢？
 A：第一个想法是合并到 root1 的树上？

 Q: 子问题是什么？
 A: 子问题就是 
 1. 如果两个树中节点都有，则相加
 2. 如果 root1 有,root2 没有，则不做操作
 3. 如果 root1 没有，root2 有，则root1 节点的值新建，并且值为 root2

 Q: 代码没有想清楚？
 A: 说明自己没有想清楚，同时也没有分析清楚

2. 看题解：
func mergeTrees(t1,t2 *TreeNode)*TreeNode {
    if t1 == nil {
        return t2
    }
    
    if t2 == nil {
   		return t1 
    }
    
    t1.Val += t2.Val
    t1.Left = mergeTrees(t1.Left,t2.Left)
    t1.Right = mergeTrees(t1.Right,t2.Right)
    return t1
}

看到广度优先遍历的时候，使用了3个队列存储感觉很麻烦，其实它本身并不麻烦，真正麻烦的是自己，是自己害怕失败，害怕错误的想法罢了

3.复杂度分析：
时间复杂度：O(n)
空间复杂度：O(n)

4.总结：
4.1: 如果你感觉到难，不要害怕，一点一点克服就好了

4.2: 如果感觉到难，说明这里是你不会的地方，一点点的搞明白就行

4.3: 其实你真正的敌人不过是你自己罢了
