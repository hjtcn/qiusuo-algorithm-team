# 第一周

## 20200914-20200919

> 本周主要刷的是数组，难易程度为简单，虽然都能自己实现，但是还是看了一些题解以及小马姐和老黑的代码，会有一些新的解题思路，进而扩宽的解题想法。

### 本周题目

-  [867] [转置矩阵](https://leetcode-cn.com/problems/transpose-matrix/description/)
-  [面试题 17.10.] [主要元素](https://leetcode-cn.com/problems/find-majority-element-lcci/)
-  [977] [有序数组的平方](https://leetcode-cn.com/problems/squares-of-a-sorted-array/description/)
-  [628] [三个数的最大乘积](https://leetcode-cn.com/problems/maximum-product-of-three-numbers/description/)
-  [1550] [存在连续三个奇数的数组](https://leetcode-cn.com/problems/three-consecutive-odds/description/)
-  [219] [存在重复元素 II](https://leetcode-cn.com/problems/contains-duplicate-ii/description/)

### 我的题解

1. [转置矩阵](../1-867转置矩阵.php)
   - php语言循环遍历二维数组`array`（涉及到key value一般常用`foreach`）。
   - go语言中数组的长度不可改变，一般使用切片`slice`，有点类似动态数组，可以后续追加元素，在追加时可能使切片的容量增大。
   - 一般二维数组如果双层遍历拿到每个元素，都需要O(m*n)的时间复杂度。
2. [主要元素](../2-面试题1710主要元素.php)
   - **PHP的数组很强大 ！**
   - 采用**hash数组**统计每个元素出现的次数，key是元素的值，value是出现的次数，如果value大于数组一半就存在主要元素。
     - 时间复杂度O(n)，只需要遍历一次数组。
     - 空间复杂度O(n)，额外申请一个`hash`数组用来计数。
   - 摩尔投票法
     - **一对一抵消**，核心思路就是如果有主要元素，那么最后留下来的那个一定是最多的。
     - 遍历整个数组，遇到相同的值就++，遇到不同的值就--。
     - 时间复杂度O(n)，遍历数组。
     - 空间复杂度O(1), 只需要申请几个变量。
3. [有序数组的平方](../3-977.有序数组的平方.php)
   - 涉及到数组一定会有遍历，可能用到`foreach`循环。
   - 涉及到有序一定会有排序，可能用到`sort`相关排序函数。
     - 相对来说排序函数时间复杂度都在O(nlogn)左右。
     - 相对有序，如果数组中间某个地方是旋转点 前面相对有序，后面相对有序，可以用到**双指针**
     - 双指针通常采用定义两个`i \ j`变量。
     - 一般双指针需要注意`while`循环条件，以及双指针移动的时机。
4. [三个数的最大乘积](../4-628.三个数的最大乘积.php)
   - 排序法
     - 三个数的乘积最大，那么直接就是想到排序，而且排序后看最大的几个数，然后拿到乘积，（负数需要考虑）。
     - 直接拿后三位进行乘积
     - 最小的两个数，和最大的数进行乘积。
   - 线性扫描直取法
     - 也可以不排序直接拿到这几个极值，并进行比较。从而降低时间复杂度为O(n)。
5. [存在连续三个奇数的数组](../5-1550.存在连续三个奇数的数组.php)
   - 奇数的判定 
     - `[√] return ( i%2 != 0 ) ? '奇数' : '偶数' ; `
     - `[√] return ( i&1 == 1 ) ? '奇数' : '偶数' ; `
   - 存在连续三个
     - 采用计数法
6. [存在重复元素](../6-219.存在重复元素-ii.php)
   - **PHP的数组很强大 ！**
   - 键值对数组采用了`hash`实现能够保证基本查找时间复杂度为 O(1)。
     - 只需要一次遍历数组，然后记录到hash哈希数组中
     - 时间复杂度 O(n)
   - 滑动窗口思路，采用双指针去维护一下k大小的滑动窗口，但是也是会双层遍历，时间复杂度略高。
     - 时间复杂度 O(n * min(n,k))


### 总结一下

#### 数组

- General
  - 时间复杂度，一般都至少要遍历一次，所以基本上都是O(n)以上。
  - 空间复杂度，一般不申请额外的空间，如hash数组，都是O(1)。
  - 常用遍历，一般采用(`foreach`、`for`、`while`)。
  - 有序，常常涉及**排序**。
  - 相对有序，常常涉及**双指针**。
  - 连续，重复，常常涉及**计数**，也会采用**Hash、Map**。
- Special
  - 摩尔投票法
  - 奇数的判定
  - 线性扫描直取法

#### 感受

- 简单。本题题目基本不难，相对来说都是比较简单的，至少能想出来一种方法。
- 扩宽。每题的解题思路扩宽，看了一些题解，融合队友的做法。
- 交流。不同语言虽然语法不同，但是解题思路才是核心的东西，也能有跟其他语言的一些互动。
- 耗时。刚开始虽然题简单，但是写题解却需要花点心思，所以可能占用时间比较长，但是会去调节。
- 完善。刷题规则也是在不断完善中，所以需要我们去发现一些问题，并且积极解决。如刷题顺序，以及一周六天，周日总结。
- 成长。当然只要有学习的心态，就能不断成长，希望我们这个刷题小队越来越好。