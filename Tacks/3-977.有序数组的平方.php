/*
 * @lc app=leetcode.cn id=977 lang=php
 *
 * [977] 有序数组的平方
 *
 * https://leetcode-cn.com/problems/squares-of-a-sorted-array/description/
 *
 * algorithms
 * Easy (71.58%)
 * Likes:    121
 * Dislikes: 0
 * Total Accepted:    45.7K
 * Total Submissions: 63.9K
 * Testcase Example:  '[-4,-1,0,3,10]'
 *
 * 给定一个按非递减顺序排序的整数数组 A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。
 * 
 * 
 * 
 * 示例 1：
 * 
 * 输入：[-4,-1,0,3,10]
 * 输出：[0,1,9,16,100]
 * 
 * 
 * 示例 2：
 * 
 * 输入：[-7,-3,2,3,11]
 * 输出：[4,9,9,49,121]
 * 
 * 
 * 
 * 
 * 提示：
 * 
 * 
 * 1 <= A.length <= 10000
 * -10000 <= A[i] <= 10000
 * A 已按非递减顺序排序。
 * 
 * 
 */

// @lc code=start
class Solution {

    /**
     * @param Integer[] $A
     * @return Integer[]
     */
    // 内置函数排序法
    // 执行用时：84 ms, 在所有 PHP 提交中击败了76.92%的用户
    // 内存消耗：17.2 MB, 在所有 PHP 提交中击败了37.50%的用户
    function sortedSquares1($A) {
        $res = []; // 结果数组
        foreach($A as $item) {
            $res[] = $item * $item;
        }
        sort($res); // sort() 函数用于对数组单元从低到高进行排序
        return $res;
    }

    /**
     * @param Integer[] $A
     * @return Integer[]
     */
    // 双指针法
    // 执行用时：84 ms, 在所有 PHP 提交中击败了76.92%的用户
    // 内存消耗：17.3 MB, 在所有 PHP 提交中击败了12.50%的用户
    function sortedSquares2($A) {
        $size = count($A); // 数组元素个数
        $res  = [];        // 结果数组
        $i    = 0;         // 初始化 负数部分指针
        $j    = 0;         // 初始化 非负部分指针
        /**
            这个地方我写错了，有误代码，我可能以为他一定有非负部分。
            foreach($A as $k=>$item) {
                if($item >= 0) {
                $j = $k; // 非负部分指针
                break;
                }
            }
        */
        // 更新如下
        while($j < $size && $A[$j] < 0 ) {
            $j++;
        }
        $i = $j - 1; // 负数部分指针
        while($i >= 0 && $j < $size) {
            if($A[$i] * $A[$i] < $A[$j] * $A[$j]) {
                $res[] = $A[$i]*$A[$i];
                $i--;
            }else{
                $res[] = $A[$j]*$A[$j];
                $j++;
            }
        }

        // 确保i j已经遍历到数组两端
        while($i >= 0) {
            $res[] = $A[$i]*$A[$i];
            $i--;
        }
        while($j < $size) {
            $res[] = $A[$j]*$A[$j];
            $j++;
        }
        return $res;
    }

    /**
     * @param Integer[] $A
     * @return Integer[]
     */
    // 看了老黑的做法 然后再做一次尝试 代码挺简短
    function sortedSquares($A) {
        $res  = []; // 结果数组
        $size = count($A);
        // 双指针
        $i     = 0;
        $j     = $size - 1;
        $index = $size - 1;
        while($i <= $j ) {
            $leftNum = $A[$i] * $A[$i];
            $rightNum= $A[$j] * $A[$j];
            if($leftNum >= $rightNum) { // 左边大 放到后面
                $res[$index--] = $leftNum;
                $i++;
            } else {
                $res[$index--] = $rightNum;
                $j--;
            }
        }
        // 但是PHP 这里就很坑,虽然数组key是0~index  
        // 但是这里返回的时候就是需要重排序一下
        // 但是结果是一样的
        return array_reverse($res);
    }


}
// @lc code=end


// @tacks think=start
/*
题意 meaning 
    一开始看到“非递减”，那就是递增呗，说的挺绕口的，实际上就是递增的一个数组A, 已经排好顺序，但是里面元素有正负。
题目要求就是对每个元素也平方计算，然后要求结果数组也是递增的排序。

关键 key 
    结果数组，“元素平方”，“递增排序”

想法 idea
【1】排序
根据题意：
    直观上看，我们直接遍历一遍数组，然后计算每个元素平方和，拿到中间结果，这个时候不确定是否整个数组是递增的，因为可能出现下面情况。
    过程①：[-4,-1,0,3,10] => 元素平方 => [16,1,0,9,100] (时间复杂度 O(n) 跟数组大小有关系)
    那么很自然的想到排个序不久解决了，其实日常开发中我们基本上是这样做的。直接sort相关函数一调用即可。
    过程②: [16,1,0,9,10]  => 排序函数 => [0,1,9,16,100] (时间复杂度 O(nlogn) O(n)基本上我们常见的排序时间复杂度最低就是这个)

综上所述：这个思路时间复杂度是O(nlogn)。

【2】双指针
深挖题意：
    为什么题目是有序数组的平方，不仅仅是要求结果数组是有序的，其实题目给的数组也是有序数组，例如[-7,-3,2,3,11]
    关键，我们如何在进行平方后仍然保持有序！
    看这个数组，我们知道 负数数组[-7,-3] 平方后是有序的 [49,9]
               同理可得 非负数组[2,3,11]平方后也是有序 [4,9,121]
               再看这个是不是有点类似，两个有序数组的合并，实际上我之前遇到过类似的题目，所以可以想到用双指针的方式。
    “「双指针」”
        我们使用两个变量 i 和 j ,分别指向 负数部分，非负部分。
        我们从后向前遍历负数部分，从前向后遍历非负部分。

    “准确找到 i 和 j的位置”
        遍历一下数组，找到第一个大于等于0的值的位置，也就是 j
        i = j - 1
    
    "双指针比较遍历"
        当前位置i的元素平方 < 当前位置j的元素平方
            结果数组 增加 当前位置i 元素的值
            i指针向左移动， 
        当前位置i的元素平方 >= 当前位置j的元素平方
            结果数组 增加 当前位置j 元素的值
            j指针向右移动
        
        可能有i或者j有一个先遍历结束，因为循环条件 while( i >= 0 && j < N )

        那么为了防止后面i j还没到数组两端，我们后面仍然需要单独遍历一次

综上所述，这个思路时间复杂度为O(n) 解法中只是用到循环。

*/
// @tacks think=end

