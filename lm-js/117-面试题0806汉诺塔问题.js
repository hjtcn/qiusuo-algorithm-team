// 面试题 08.06. 汉诺塔问题
// 在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:
// (1) 每次只能移动一个盘子;
// (2) 盘子只能从柱子顶端滑出移到下一根柱子;
// (3) 盘子只能叠在比它大的盘子上。

// 请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。

// 你需要原地修改栈。

// 示例1:

//  输入：A = [2, 1, 0], B = [], C = []
//  输出：C = [2, 1, 0]
// 示例2:

//  输入：A = [1, 0], B = [], C = []
//  输出：C = [1, 0]
// 提示:

// A中盘子的数目不大于14个。


/*
    思路：
    首先我一开始没有用递归，而是选择用栈去直接模拟移动的操作，然后发现再赋值结束之后，发现return的时候，怎么都不对，感觉好像不能使用=赋值的感觉。
    
    后来看了题解后，js好像就只能利用栈的push和pop方法进行操作。
    下面来看看汉诺塔的真个思路，可以看看官方的动图后就非常清晰了
    https://leetcode-cn.com/problems/hanota-lcci/solution/tu-jie-yi-nuo-ta-de-gu-shi-ju-shuo-dang-64ge-pan-z/


    分治：
    n = 1 时，直接把盘子从 A 移到 C；
    n > 1 时，
    先把上面 n - 1 个盘子从 A 移到 B（子问题，递归）；
    再将最大的盘子从 A 移到 C；
    再将 B 上 n - 1 个盘子从 B 移到 C（子问题，递归）。

    题目也要细看，是从第一根移到最后一根柱子，即从A到C

    这哪是是简单题啊，代码是简单，思路很巧妙

    最近手里有活，没有继续研究迭代方法，等着向同胞们取取经。


*/
/**
 * @param {number[]} A
 * @param {number[]} B
 * @param {number[]} C
 * @return {void} Do not return anything, modify C in-place instead.
 */
var hanota = function(A, B, C) {
    let len=A.length
    let dfs=(len,A,B,C)=>{
       if(len==1){
           C.push(A.pop())
       }
       else{
           dfs(len-1,A,C,B)//A中len-1个盘子借助C移到B
           C.push(A.pop())
           dfs(len-1,B,A,C)//B中len-1个盘子借助A移到C
       }
    }
    /*
    第一个参数len判断是否A只剩一个盘子了
    第二个参数A是目标移动柱子
    第三个参数B是辅助柱子
    第四个参数C是目标到达柱子。
    */
    dfs(len,A,B,C)
};