给你二叉树的根结点 root ，请你将它展开为一个单链表：

展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。
展开后的单链表应该与二叉树 先序遍历 顺序相同。
 
示例 1：
输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]

示例 2：
输入：root = []
输出：[]

示例 3：
输入：root = [0]
输出：[0]
 
提示：
树中结点数在范围 [0, 2000] 内
-100 <= Node.val <= 100
 进阶：你可以使用原地算法（O(1) 额外空间）展开这棵树吗？

1. Clarification:
 使用一个链表记录
前序遍历二叉树
然后将节点放到这个里面

想了下上面的思路不太行，需要换一种思路

2. 看题解：
前序遍历：
二叉树展开，将二叉树前序遍历的结果放入到数组中
然后对数据进行遍历，进行连接
func flatten(root *TreeNode)  {
    list := preorderTraversal(root)
    for i := 1; i < len(list); i++ {
        prev, curr := list[i-1], list[i]
        prev.Left, prev.Right = nil, curr
    }
}
二叉树的迭代实现前序遍历


之所以会在破坏二叉树的结构之后丢失子节点的信息，是因为在对左子树进行遍历的时候，没有存储右子节点的信息，在遍历完左子树之后才获得右子节点的信息。
只要对前序遍历进行修改，在遍历左子树之前就获得左右子节点的信息，并存入栈内，子节点的信息就不会丢失。

如果一个节点的左子节点为空，则该节点不需要进行展开操作。如果一个节点的左子节点不为空，则该节点的左子树中的最后一个节点被访问之后，该节点的右子节点被访问。该节点的左子树中最后一个被访问的节点是左子树中的最右边的节点，也是该节点的前驱节点。因此，问题转化成寻找当前节点的前驱节点。

具体：
对于当前节点，如果其左子节点不为空，则在其左子树中找到最右边的节点，作为前驱节点，将当前节点的右子节点赋给前驱节点的右子节点，然后将当前节点的左子节点赋给当前节点的右子节点，并将当前节点的左子节点设为空。对当前节点处理结束后，继续处理链表中的下一个节点，直到所有节点都处理结束。

unc flatten(root *TreeNode)  {
    curr := root
    for curr != nil {
        if curr.Left != nil {
            next := curr.Left
            predecessor := next
            for predecessor.Right != nil {
                predecessor = predecessor.Right
            }
            predecessor.Right = curr.Right
            curr.Left, curr.Right = nil, next
        }
        curr = curr.Right
    }
}

3. 复杂度分析：
时间复杂度:O(n)
空间复杂度:O(1)

4. 总结：
4.1: 如果你对这个问题真的理解了，是可以用文字描述清楚的，如果描述不清楚的话，说明你对这个问题还没有真正理解
