// 3. 无重复字符的最长子串
// 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

 

// 示例 1:

// 输入: s = "abcabcbb"
// 输出: 3 
// 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
// 示例 2:

// 输入: s = "bbbbb"
// 输出: 1
// 解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
// 示例 3:

// 输入: s = "pwwkew"
// 输出: 3
// 解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
//      请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
// 示例 4:

// 输入: s = ""
// 输出: 0
 

// 提示：

// 0 <= s.length <= 5 * 104
// s 由英文字母、数字、符号和空格组成


/*
    思路：距离放弃只有一点点。
         今天还是比较机智的，想到了子串可以用滑动窗口控制左右指针来做。
         但是细节太多了，啊啊啊，走一步一个坑。
         先说说思路：
         1.如果该字符已经出现过，left指针等于之前的索引值。
         2.其余情况right指针在遍历中一直+1，并且用map更新s[i]所在位置，max更新最大值。
        
         说说坑吧，这玩意要自己遇：
         1.记录位置记录i+1,这样好控制map.get(s[i])的判断。
         2.left初始值为1，返回值right-left+1,如果right一直+1，left一直为0而不是1，这样返回值会出现多+1的情况。如："abcabcbb"
         3.left要更新最大值，不然，走到最后一个值，竟然和第一个值相同，left又变为2.这样最大值也会出现不准确的情况。

         申请这种题也多来几次，不然总结不出模版，是否能做出来完全看缘分，细节有点多。

         看了看题解，思路都基本差不多，但细节控制的方向不同。想了想还是自己总结吧。我需要多看几次，实在不行，就死记硬背后再总结。。。

*/


var lengthOfLongestSubstring = function(s) {
    let left=1,right=0,map=new Map(),max=0
    for(let i=0;i<s.length;i++){
        //如果出现过，就更新left值，为之前所在位置+1.
        //当然left也要保持不断递增，因此取最大值
        if(map.get(s[i])){
            left=Math.max(map.get(s[i])+1,left)
        }
        right++;
        //map记录所在位置
        map.set(s[i],i+1)
        //更新最长子串长度
        max=Math.max(right-left+1,max)
    }
    return max
};

/*
    时间复杂度：O(N)
    空间复杂度：O(N)

*/