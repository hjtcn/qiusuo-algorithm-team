<?php
/*
 * @Descripttion: 终于看懂了题呜呜呜呜呜
 * @Author: tacks321@qq.com
 * @Date: 2021-06-18 16:17:20
 * @LastEditTime: 2021-06-18 18:27:18
 */


/*
 * @lc app=leetcode.cn id=210 lang=php
 *
 * [210] 课程表 II
 *
 * https://leetcode-cn.com/problems/course-schedule-ii/description/
 *
 * algorithms
 * Medium (53.54%)
 * Likes:    418
 * Dislikes: 0
 * Total Accepted:    74.1K
 * Total Submissions: 138.3K
 * Testcase Example:  '2\n[[1,0]]'
 *
 * 现在你总共有 n 门课需要选，记为 0 到 n-1。
 * 
 * 在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]
 * 
 * 给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。
 * 
 * 可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。
 * 
 * 示例 1:
 * 
 * 输入: 2, [[1,0]] 
 * 输出: [0,1]
 * 解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。
 * 
 * 示例 2:
 * 
 * 输入: 4, [[1,0],[2,0],[3,1],[3,2]]
 * 输出: [0,1,2,3] or [0,2,1,3]
 * 解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。
 * 因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。
 * 
 * 
 * 说明:
 * 
 * 
 * 输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。
 * 你可以假定输入的先决条件中没有重复的边。
 * 
 * 
 * 提示:
 * 
 * 
 * 这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。
 * 通过 DFS 进行拓扑排序 - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。
 * 
 * 拓扑排序也可以通过 BFS 完成。
 * 
 * 
 * 
 */

// @lc code=start
class Solution {

    /**
     * @param int $numCourses       4
     * @param array $prerequisites [[1,0],[2,0],[3,1],[3,2]]
     * @return array
     */
    // 拓扑排序：Kahn算法
    // 执行用时：36 ms, 在所有 PHP 提交中击败了90.91%的用户
    // 内存消耗：19.1 MB, 在所有 PHP 提交中击败了72.73%的用户
    function findOrder($numCourses, $prerequisites) {
        // 边界判断
        if($numCourses <= 0) {
            return [];
        }

        //////////////////////【1】初始化（构造我们需要的数据结构）///////////////////////////////////////////////////////
        $adj      = array_fill(0, $numCourses, []);  // 邻接关系表
        $inDegree = array_fill(0, $numCourses, 0);   // 统计每个顶点的引入次数

        // 【邻接表 adj 】 通过结点的索引，我们能够得到这个结点的后继结点
        // 【入度数组 inDegree】 通过结点的索引，我们能够得到指向这个结点的结点个数
        foreach($prerequisites as $p) {
            $adj[$p[1]][] = $p[0]; 
            $inDegree[$p[0]]++;
        }

        /*
        例如 [[1,0],[2,0],[3,1],[3,2]]
        创建的邻接表就是 是有箭头的
                  1  
               ／   ＼ 
             0 ＼   ／ 3
                  2
            adj[0][0] = 1 (0第一个后继节点1)
            adj[0][1] = 2 (0第二个后继节点2)
            adj[1][0] = 3 (1第一个后继节点3)
            adj[2][0] = 3 (2第一个后继节点3)

        创建的入度数组就是
            inDegree[0] = 0 (这个是开始的时候就默认填充的)
            下面三个都是遍历数组得到的            
            inDegree[1] = 1 
            inDegree[2] = 1
            inDegree[3] = 2
            
        */


        //////////////////////【2】入队（将入度0的都加进去）///////////////////////////////////////////////////////


        /*
            入队操作
                这个地方就类似，BFS中的
                    $queue = [$root]; // 队列 根节点入队
                而有向图中，需要将入度为0的都加入队列中，因此需要遍历
        */
        $queue = []; // 队列
        for ($i=0; $i < $numCourses ; $i++) { 
            // 入度为0的入队
            if($inDegree[$i] == 0) {
                array_push($queue, $i); 
            }
        }


        //////////////////////【3】出队（每次出队进行操作并判断，直到队列中没有0度的节点）///////////////////////////////////////////////////////
        $ans = [];
        while(!empty($queue)) {
            // 就从队首取出入度为 0 的结点
            $num = array_shift($queue); // 弹出

             /*
                出队操作：节点处理
                    1、加入结果集
                    2、满足条件的继续入队                
            */

            $ans[] = $num; // 将这个结点输出到结果集中

            // 遍历 这个结点的所有邻接结点（它指向的结点）
            foreach($adj[$num] as $node) {
                $inDegree[$node]--; // 入度减 1

                // 如果这个被减 1 的结点的入度为 0 ，就继续入队
                if($inDegree[$node] == 0) {
                    array_push($queue, $node);
                }
            }
        }

        // 检查结果集中的顶点个数是否和课程数相等
        return count($ans) == $numCourses ? $ans : [];
        
    }
}
// @lc code=end

/*
【题目】
    选择课程有先决条件，有些课程必须在上完前面的课程才能向后学习。

    这也就是约定一个课程选择的先后规则。如果我们穿衣服一样，先穿里面的内衣，然后穿外面的衣服。

    因此需要引入有向图的一个思想，通过有向图来描述依赖关系。

    出度（Out-degree）和入度（In-degree）：
        对有向图而言，顶点的度还可分为出度和入度。
        一个顶点的出度为do，是指有do条边以该顶点为起点，或说与该点关联的出边共有do条。入度的概念也类似。

    所以每次必须首先选择入度为0的课程，也就是不需要先决条件的课程，也就是最基础的课程，学完之后才能进修。
    知道没有入度为0的课程，遍历结束

【参考】
    https://leetcode-cn.com/problems/course-schedule-ii/solution/bao-mu-shi-ti-jie-tuo-bu-pai-xu-si-lu-zen-yao-yi-2/
    
    
【解析】
    有向无环图：DAG (Directed Acyclic Graph)
        如果给图的每条边规定一个方向，那么得到的图称为有向图，其边也称为有向边。
        在有向图中，与一个节点相关联的边有出边和入边之分，而与一个有向边关联的两个点也有始点和终点之分。
        相反，边没有方向的图称为无向图。　
    
    本题主要是考察 拓扑排序 Topological Sorting
        拓扑排序 
            1、Kahn算法
                借助 BFS+贪心 应用于 有向无环图 的一种写法
                a、拓扑序不唯一
                b、可以用于检测有向图是否有环
            2、DFS算法
                略复杂暂缓

        BFS 模板
        while(count($queue)) {
            $node = array_shift($queue);  // 队列 先进先出 移除头部节点
            
            if($node->left != null ) {
                $queue[] = $node->left;   // 入队
            }
            if($node->right != null) {
                $queue[] = $node->right;  // 入队
            }
        }


    复杂度
        时间复杂度: O(n+m)，
            其中 nn 为课程数，mm 为先修课程的要求数。这其实就是对图进行深度优先搜索的时间复杂度。

        空间复杂度: O(n+m)
            题目中是以列表形式给出的先修课程关系，为了对图进行深度优先搜索，我们需要存储成邻接表的形式，空间复杂度为 O(n+m)。
            在深度优先搜索的过程中，我们需要最多 O(n) 的栈空间（递归）进行深度优先搜索，并且还需要若干个 O(n) 的空间存储节点状态、最终答案等。
 
*/