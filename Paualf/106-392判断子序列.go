给定字符串 s 和 t ，判断 s 是否为 t 的子序列。
字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。
进阶：
如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？
致谢：
特别感谢 @pbrother 添加此问题并且创建所有测试用例。
 
示例 1：
输入：s = "abc", t = "ahbgdc"
输出：true
示例 2：
输入：s = "axc", t = "ahbgdc"
输出：false
提示：
• 0 <= s.length <= 100
• 0 <= t.length <= 10^4
• 两个字符串都只由小写字符组成。
    1. Clearficaion:
        ahbgdc 找出它的所有子序列，将所有不同长度的子序列放到一起
        然后根据 s 的长度，首先判断t中是否有该长度的元素，如果没有则返回false
        如果有，则去匹配中间是否含有 abc，如果有返回 true,没有返回false

    2. Coding:
        如何找到t的所有不同长度的子序列呢？
            l = 2的时候
                ah
                ab
                ag
                ad
                ac
                hb
                hg
                hd
                hc
                bd
                bd
                bc
                
            l = 3
func isSubsequence(s string, t string) bool {
}   
这个代码时间复杂度蛮高的，理论上是可行的，使用递归去解决这个问题，现在的我没有想到怎么去写

3. 看题解：
贪心思路：
从前往后匹配，每次贪心地匹配靠前的字符是最优决策。
思路细节：
初始化两个指针i和j，分别指向s和t的初始位置。每次贪心地匹配，匹配成功则i和j同时右移，匹配s的下一个位置，匹配失败则j右移，i不变，尝试用t的下一个字符匹配s。
最终如果i移动到s的末尾，就说明s是t的子序列。
func isSubsequence(s string,t string) bool {
    n,m := len(s),len(t)
    i,j := 0,0
    
    for i < n && j < m {
        if s[i] == s[j] {
            i++
        }
        j++
    }
    
    return i == n
}
动态规划晚上看就是要命。。。

4. 复杂度分析：
时间复杂度：O(n+m)
空间复杂度：O(1)

5. 总结：
5.1: 自己思路可能是想偏了，像贪心这样，如果不知道就是不知道

5.2: 动态规划这种题目不适合晚上看，打算明天再看下（捂脸）
