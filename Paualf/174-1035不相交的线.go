在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。
现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足满足：
 nums1[i] == nums2[j]
且绘制的直线不与任何其他连线（非水平线）相交。
请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。
以这种方法绘制线条，并返回可以绘制的最大连线数。
示例 1：
输入：nums1 = [1,4,2], nums2 = [1,2,4]
输出：2
解释：可以画出两条不交叉的线，如上图所示。 
但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。
示例 2：
输入：nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2]
输出：3
示例 3：
输入：nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1]
输出：2
 
提示：
1 <= nums1.length <= 500
1 <= nums2.length <= 500
1 <= nums1[i], nums2[i] <= 2000
1. Clarfication:
    怎么划线不相交
        怎么去分析定义这个问题？
        定义问题
        解决问题
        
        看了题解转换成二维数组的最长公共子序列
        动态规划五部曲
        1 4 2
      0 0 0 0 
    1 0 1 1 1
    2 0 1 1 2
    4 0 1 2 2 
      
 1. dp定义
        dp[i][j] 表示 [0-i][0-j] 的最长公共子序列

2. 动态规划方程
        if nums[i] == nums2[j] {
            dp[i][j] = dp[i-1][j-1] + 1
        }else {
            dp[i][j] = max(dp[i-1][j],dp[i][j-1])
        }

3. 初始化：
从上面的图中可以看出，dp[0][i] = 0, i 从 [0->m]
                                 dp[j][0] = 0, j 从[0->n]
4. 遍历顺序
从低到高

5. case by  case

func maxUncrossedLines(nums1 []int, nums2 []int) int {
    m,n := len(nums1),len(nums2)
    if m == 0 || n ==0 {
        return 0
    }
    dp := make([][]int, m + 1)
    for i := 0;i < m + 1;i ++ {
        dp[i] = make([]int, n + 1)
    }
    for i := 1;i < m + 1;i++ {
        for j := 1;j < n + 1;j++ {
            if nums1[i-1] == nums2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            }else {
                dp[i][j] = max(dp[i-1][j],dp[i][j-1])
            }
        }
    }
    return dp[m][n]
}

func max(x,y int)int {
    if x > y {
        return x
    }
    return y
}

2. 看题解：
一开始有点懵，看了题解可以转化成最长公共子序列就了解了

3. 复杂度分析：
时间复杂度：O(mn)
空间复杂度：O(n)

4. 总结：
4.1: 将抽象成具体的问题用代码去解决我目前感觉是最难的，如产品给你一个需求，然后你要把里面真正的需求找出来，然后用项目中的组件去实现，这个比写代码难的多，写代码只是实现就行了。真正难的不是实现，是抽象，是把实际问题抽象成可以解决的问题。

4.2: 技术方案：要像施工地图一样详细，尽可能的去完善自己的技术方案，让别人看懂为什么这样写，这样写带来了什么收益，解决了什么问题。
