# 529. 扫雷游戏
> LeetCode地址：[访问](https://leetcode-cn.com/problems/minesweeper/) <br/>
> Github地址：[访问](/)

## 题目及题意分析

### 题目
让我们一起来玩扫雷游戏！

给定一个代表游戏板的二维字符矩阵。 'M' 代表一个未挖出的地雷，'E' 代表一个未挖出的空方块，'B' 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的已挖出的空白方块，数字（'1' 到 '8'）表示有多少地雷与这块已挖出的方块相邻，'X' 则表示一个已挖出的地雷。

现在给出在所有未挖出的方块中（'M'或者'E'）的下一个点击位置（行和列索引），根据以下规则，返回相应位置被点击后对应的面板：

1. 如果一个地雷（'M'）被挖出，游戏就结束了- 把它改为 'X'。
2. 如果一个没有相邻地雷的空方块（'E'）被挖出，修改它为（'B'），并且所有和其相邻的未挖出方块都应该被递归地揭露。
3. 如果一个至少与一个地雷相邻的空方块（'E'）被挖出，修改它为数字（'1'到'8'），表示相邻地雷的数量。
4. 如果在此次点击中，若无更多方块可被揭露，则返回面板。

注意：

1. 输入矩阵的宽和高的范围为 [1,50]。
1. 点击的位置只能是未被挖出的方块 ('M' 或者 'E')，这也意味着面板至少包含一个可点击的方块。
1. 输入面板不会是游戏结束的状态（即有地雷已被挖出）。
1. 简单起见，未提及的规则在这个问题中可被忽略。例如，当游戏结束时你不需要挖出所有地雷，考虑所有你可能赢得游戏或标记方块的情况。


**示例：**

```
示例 1：

输入: 

[['E', 'E', 'E', 'E', 'E'],
 ['E', 'E', 'M', 'E', 'E'],
 ['E', 'E', 'E', 'E', 'E'],
 ['E', 'E', 'E', 'E', 'E']]

Click : [3,0]

输出: 

[['B', '1', 'E', '1', 'B'],
 ['B', '1', 'M', '1', 'B'],
 ['B', '1', '1', '1', 'B'],
 ['B', 'B', 'B', 'B', 'B']]

```
![image](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/minesweeper_example_1.png)

```
输入: 

[['B', '1', 'E', '1', 'B'],
 ['B', '1', 'M', '1', 'B'],
 ['B', '1', '1', '1', 'B'],
 ['B', 'B', 'B', 'B', 'B']]

Click : [1,2]

输出: 

[['B', '1', 'E', '1', 'B'],
 ['B', '1', 'X', '1', 'B'],
 ['B', '1', '1', '1', 'B'],
 ['B', 'B', 'B', 'B', 'B']]

```
![image](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/minesweeper_example_2.png)

### 题意
 
**由题意与示例分析，示例应判断出如下内容**
1. 只处理一次点击行为
2. 只有八个方向没有地雷时才进行递归
3. 点到地雷直接结束

### 解题思路


**逻辑梳理**

1. 【递归】判断当前处理的坐标下的数值是什么
 - M，修改为X，结束
 - E，判断此坐标周围的M个数
    - 0个， 赋值为B，分别递归八个方向
    - 其他，赋值为M个数
 1. 【结束】


## 代码实现

**正确代码**

```
function updateBoard(board: string[][], click: number[]): string[][] {
    
    return dfs(click[0], click[1]);
    function dfs(xAxis, yAxis){
        const xBoard = board[xAxis];
        if(xBoard && yAxis >= 0){
            const value = xBoard[yAxis];
        if(value === 'M'){
            board[xAxis][yAxis] = 'X';
        }else if(value === 'E') {
            const num = sumM(board, [xAxis, yAxis]);
            if(num === 0) {
                board[xAxis][yAxis] = 'B';
                dfs(xAxis-1, yAxis-1);
                dfs(xAxis, yAxis-1);
                dfs(xAxis+1, yAxis-1);
                dfs(xAxis-1, yAxis);

                dfs(xAxis, yAxis+1);
                dfs(xAxis-1, yAxis+1);
                dfs(xAxis+1, yAxis);
                dfs(xAxis+1, yAxis+1);
            }else{
                board[xAxis][yAxis] = '' + num;
            }
        }
        
        }
        return board;
    }
    
};

function sumM (board: string[][], click: number[]): number {
    const x = click[0], y = click[1];
    
    return isM(x-1, y-1) + isM(x, y-1)
    + isM(x+1, y-1) + isM(x-1, y)
    + isM(x, y+1) + isM(x-1, y+1)
    + isM(x+1, y) + isM(x+1, y+1)


    function isM(clickX: number, clickY: number) {
        const xBoard = board[clickX];
        return xBoard && xBoard[clickY] === 'M' ? 1 : 0;
    }
}
```
## 总结：
- 正确的理解、分析题目很重要。
- 在对于坐标的变化上最好可以用纸写一写不容易乱。
- 对八个方向的坐标处理可以使用循环完成，提高代码的可读性和逻辑性。
