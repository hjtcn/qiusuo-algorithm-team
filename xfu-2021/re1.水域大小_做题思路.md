# 面试题 16.19. 水域大小

> LeetCode地址：[访问](https://leetcode-cn.com/problems/pond-sizes-lcci/) <br/>
> Github地址：[访问](/)

## 题目及题意分析

### 题目

你有一个用于表示一片土地的整数矩阵land，该矩阵中每个点的值代表对应地点的海拔高度。若值为0则表示水域。由垂直、水平或对角连接的水域为池塘。池塘的大小是指相连接的水域的个数。编写一个方法来计算矩阵中所有池塘的大小，返回值需要从小到大排序。

**示例：**

```

输入：
[
  [0,2,1,0],
  [0,1,0,1],
  [1,1,0,1],
  [0,1,0,1]
]
输出： [1,2,4]
提示：

0 < len(land) <= 1000
0 < len(land[i]) <= 1000
```

### 题意

1. 使用一个二维数组表示一个矩形的区域
2. 需要计算区域内所有的水域（值为0）大小
    - 垂直、水平、对角相连的算做一个水域
    - 没有相邻的话，单个也算一个水域
3. 计算结果需要从小到大排序，且无需去重
 
**由题意与示例分析，示例应判断出如下内容**

```
// 示例
[
  [0,2,1,0],
  [0,1,0,1],
  [1,1,0,1],
  [0,1,0,1]
]

// 应计算出的结果1 => 2
[
    [0, ...],
    [0, ...],
    ...
]
// 应计算出的结果2 => 4
[
    [..., 0],
    [.., 0, .],
    [.., 0, .],
    [.., 0, .],
]
// 应计算出的结果3 => 1
[
    [....],
    [....],
    [....],
    [0, ...],
]

```

## 解题思路

### 初步构想

先遍历，找到一个水域开始的点。并从这个点开始，判断他的右、下、左下、右下四个方向的点的值，按照顺序进入该点，递归判断并进入值为0的点。最后保存一次大判断时判断出来的数量。

**逻辑梳理**
- 定义，保存所有已判断结束的水域大小数组 areaList:number[]
- 定义，表示二维数组的坐标
    - 纵向坐标变化=> yAxis:number = 0
    - 横向坐标变化=> xAxis:number = 0
- 定义，表示起始水域位置的坐标变量
    - 纵向坐标=> syAxis:number = -1
    - 横向坐标=> sxAxis:number = -1
- 定义，表示水域大小的变量=> areaSize:number = 0
- 【start】开始遍历二维数组
    - yAxis为外层遍历index， xAxis为内层遍历index
    - 【1】判断，当本次遍历找到了第一个位置是0的值时：
        - areaSize = 1 （++）
        - 当前坐标的值修改为 -1（避免和其他值混淆）
    - 分别判断 右边的值 、 下边的值 、 右下的值、左下的值
        - 值不存在或者不为0则无需处理
        - 值为0
            - 记录当前值所在坐标 syAxis = yAxis , sxAxis = xAxis
            - yAxis和xAixs移动到对应的坐标位置
            - 递归的执行【1】之后的行为
        - 当右 和下 的值都不存在或者不为0时
            - 将areaSize的值push进areaList中
            - 清空areaSize
            - 若syAxis和 sxAxis存在并不为-1
                - 修改yAxis和xAxis的值为syAxis和sxAxis的值
                - syAxis 和 sxAxis的值设置为-1
            - 其他情况
                - - syAxis 和 sxAxis的值设置为-1
                - 继续之后的遍历，并执行【1】操作
- 【end】对areaList进行排序
 
**问题**

在梳理完逻辑发现了一个很重要的问题，当判断某一个点的周围有为0的点时，保存了当前点的坐标，可是当新移动到的点周围也有点时，递归处理又会修改坐标，这样就会导致位置永远只能回到移动之前的上一个位置，上上个位置无法回去。因此逻辑有问题。


**解决**

思考了一下，并查阅了下解析的思路。
1. 这个问题其实递归就可以解决，根本没有必要记录开始处理的坐标。每一次‘移动’都是一个递归开始
2. 解析中都是判断的八个方向，但是我觉得只需要四个方向（右、右下、下、左下）。因为遍历是按照顺序从上到下、从左到右的执行。我觉得其他四个方位（左、左上、上、右上）的值即使存在也只可能是不为0的值，假设为0,那么在之前的判断中当前水域就一定判断过了，而上面的逻辑中判断过的值被直接修改了。【已分析修正，此想法有误↓】
 
**逻辑重新梳理**

- 定义，保存所有已判断结束的水域大小数组 areaList:number[]
- 定义，表示二维数组的坐标
    - 纵向坐标变化=> yAxis:number = 0
    - 横向坐标变化=> xAxis:number = 0
- 定义，表示水域大小的变量=> areaSize:number = 0
- 【start】开始遍历二维数组
    - yAxis为外层遍历index， xAxis为内层遍历index
    - 【1】判断，当本次遍历找到了一个位置是0的值时：
        - areaSize = 1 （++）
        - 当前坐标的值修改为 -1（避免和其他值混淆）
    - 分别判断 右边的值 、 下边的值 、 右下的值、左下的值
        - 值不存在或者不为0则无需处理
        - 值为0，递归的从【1】开始执行
        - 当四个方向的值都不存在或者不为0时
            - 将areaSize的值push进areaList中
            - areaSize = 0
            - 继续之后的遍历
- 【end】对areaList进行排序

### 代码实现

**失败代码1**

```
function pondSizes(land: number[][]): number[] {
    const areaList:number[] = [];
    let areaSize = 0;

    land.forEach((landLayout, yAxis) => {
        landLayout.forEach((num, xAxis) => {
            DFS(xAxis, yAxis);
        })
    })

    function DFS(xAxis: number, yAxis: number){
        const landRound = land[yAxis];
        if(!landRound) return;
        
        const num = landRound[xAxis];

        if(num === 0){
            areaSize ++;
            land[yAxis][xAxis] = -1;
            DFS(xAxis + 1, yAxis); // 右
            DFS(xAxis - 1, yAxis + 1); // 左下
            DFS(xAxis, yAxis + 1); // 下
            DFS(xAxis + 1, yAxis + 1); // 右下
        }else{
            if(areaSize > 0){
                areaList.push(areaSize);
                areaSize = 0;
            }
        }
    }

    return areaList.sort((a, b) => a-b);
};
```


```
// 输入
[[0,2,1,0],[0,1,0,1],[1,1,0,1],[0,1,0,1]]
// 输出
[1,1,1,1,1,1,1]
// 预期结果
[1,2,4]
```
分析：没有判断必须四个方向的值都不为0才算结束

**失败代码2**
```
function pondSizes(land: number[][]): number[] {
    const areaList:number[] = [];
    let areaSize = 0;

    land.forEach((landLayout, yAxis) => {
        landLayout.forEach((num, xAxis) => {
            DFS(xAxis, yAxis);
        })
    })

    function DFS(xAxis: number, yAxis: number){
        const landRound = land[yAxis];
        if(!landRound) return;

        const num = landRound[xAxis];

        if(num === 0){
            areaSize ++;
            land[yAxis][xAxis] = -1;
            DFS(xAxis + 1, yAxis); // 右
            DFS(xAxis - 1, yAxis + 1); // 左下
            DFS(xAxis, yAxis + 1); // 下
            DFS(xAxis + 1, yAxis + 1); // 右下
            
            // 只有判断出了水域大小才保存值
            if(areaSize){
                areaList.push(areaSize);
                areaSize = 0;
            }
        }
    }

    return areaList.sort((a, b) => a-b);
};

```


```
// 输入
[[2,8,8,4,1,7,1,5,4,2,0,8,1,9,2,5,6,9,7,4,8,9,1,7,3,6,9,3,7,1,5,7,3,1,9,9,9,6,5,1,9,9,4,1,6,4,7,6,1,6,1,3,3,9,0,3,0,0,0,1,3,1,2,0,0,0,3,2,7,3,6,7,9],[2,0,9,8,2,0,5,8,4,0,4,5,2,1,5,6,0,6,3,3,6,9,5,4,0,9,4,7,1,4,2,8,9,8,0,6,3,5,7,2,1,6,8,4,8,4,6,5,0,3,7,1,7,6,3,0,2,2,2,3,2,4,7,7,6,8,2,9,2,5,0,3,8],[2,7,0,1,1,3,6,5,6,0,7,0,2,4,5,0,3,7,3,1,5,7,9,8,8,0,9,8,1,9,4,7,5,6,5,4,1,7,7,4,4,3,8,3,5,3,3,8,7,4,5,4,8,0,2,0,4,7,5,4,3,9,1,9,4,9,2,2,2,4,1,2,9],[6,0,4,4,6,7,8,8,9,9,5,4,9,7,0,4,2,7,1,9,2,2,9,2,4,3,0,5,1,7,8,9,0,5,3,3,3,1,1,7,1,2,7,5,6,8,7,2,3,1,5,3,5,7,9,7,7,8,8,7,2,4,4,2,8,2,3,2,1,9,1,2,7],[2,5,1,2,2,5,8,2,8,7,4,5,9,8,9,6,0,9,7,0,5,8,8,3,3,8,1,9,4,8,2,3,4,9,1,2,4,5,1,5,4,4,6,9,2,3,3,1,2,2,4,1,2,7,4,6,9,2,3,5,9,7,7,4,9,9,4,7,1,5,5,7,6],[9,9,9,1,8,3,3,4,6,5,7,7,3,1,1,3,9,2,7,0,6,8,8,0,2,9,6,6,4,4,6,2,6,6,1,7,5,6,4,9,6,9,8,2,1,4,3,4,6,6,8,6,4,7,8,3,7,1,3,7,5,3,2,1,4,7,9,7,3,4,9,0,1],[7,1,4,9,7,2,1,9,0,9,7,4,5,3,5,2,6,5,6,0,5,0,5,3,1,1,7,9,6,2,1,8,3,4,7,4,2,1,3,5,9,7,7,5,6,1,0,3,6,3,7,9,6,5,1,...
// 输出
[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,4,5,6]
// 预期结果
[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,3,3,3,3,3,3,3,3,4,6,6,8]

```
分析：考虑错误，把areaSize的判断放到了递归内部进行。这样的逻辑是错误的，并不能保证本次递归判断全部已经结束了。

**正确代码**

```
function pondSizes(land: number[][]): number[] {
    const areaList:number[] = [];
    let areaSize = 0;

    land.forEach((landLayout, yAxis) => {
        landLayout.forEach((num, xAxis) => {
            DFS(xAxis, yAxis);
            // 只有判断出了水域大小才保存值
            if(areaSize){
                areaList.push(areaSize);
                areaSize = 0;
            }
        })
    })

    function DFS(xAxis: number, yAxis: number){
        // 判断外层边界
        const landRound = land[yAxis];
        if(!landRound) return;

        const num = landRound[xAxis];

        if(num === 0){
            areaSize ++;
            land[yAxis][xAxis] = -1;
            // 有判断这四个方向的必要，因为再深度遍历的时候可能只有一个方向判断过
            DFS(xAxis - 1, yAxis); // 左
            DFS(xAxis - 1, yAxis - 1); // 左上
            DFS(xAxis, yAxis - 1); // 上
            DFS(xAxis + 1, yAxis - 1); // 右上

            DFS(xAxis + 1, yAxis); // 右
            DFS(xAxis - 1, yAxis + 1); // 左下
            DFS(xAxis, yAxis + 1); // 下
            DFS(xAxis + 1, yAxis + 1); // 右下
            
        }
    }

    return areaList.sort((a, b) => a-b);
};
```
通过分析与测试，发现还是非常有必要判断八个方向的【上面的思考】。因为在递归内部进行遍历时，已经不按照原本的顺序执行了，新移动到位置的八个方向不一定已经被判断了，因此需要判断八个方向，以避免判断偏差。