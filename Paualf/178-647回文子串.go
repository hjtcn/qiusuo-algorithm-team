给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。
具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。
 
示例 1：
输入："abc"
输出：3
解释：三个回文子串: "a", "b", "c"
示例 2：
输入："aaa"
输出：6
解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"
 
提示：
输入的字符串长度不会超过 1000 。

  1. 分解子问题
      a a a
    0 1 1 1
  a 1 
  a 1
  a 1
     没想出来怎么分解子问题和dp变化

2. 看题解:
动态规划五部曲：
1. 确定dp数组（dp table) 以及下标的含义
布尔类型的dp[i][j]: 表示区间范围[i,j] (注意是左闭右闭）的子串是否是回文子串，如果是dp[i][j] 为 true，否则为false

2. 确定递归公式
感觉这里是精髓也是自己分析不明白的地方：
整体：s[i] 与 s[j] 是否相等
s[i] 与 s[j] 不想等，那没啥好说的，dp[i][j] 一定是false
s[i] 与 s[j] 相等，分三种情况：
1. 下标i与j相同，同一个字符例如a
2. 下标i与j相差为1，例如aa
3. i与j相差大于1的时候，如 cabac, s[i] 与 s[j] 已经相同了

3. dp数组如何初始化：
dp[i][j] = false

4. 遍历顺序
因为用到 dp[i-1][j-1] 所以遍历顺序要从下到上

5. case by case
j > i 的，这一点也是值得思考的

func countSubstrings(s string) int {
    res:=0
    dp:=make([][]bool,len(s))
    for i:=0;i<len(s);i++{
        dp[i]=make([]bool,len(s))
    }

    for i:=len(s)-1;i>=0;i--{
        for j:=i;j<len(s);j++{
            if s[i]==s[j]{
                if j-i<=1{
                    res++
                    dp[i][j]=true
                }else if dp[i+1][j-1]{
                    res++
                    dp[i][j]=true
                }
            }
        }
    }
    return res
}

3. 复杂度分析：
时间复杂度：O(m x n)
空间复杂度: O (m)

4. 总结：
4.1: 对这种复杂的问题，需要分1，2，3 进行分析的会有点害怕，也没有静下心来去分析，后面需要注意下这些
