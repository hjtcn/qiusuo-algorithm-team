# 面试题 08.01. 三步问题

> LeetCode地址：[访问](https://leetcode-cn.com/problems/three-steps-problem-lcci/) 
Github地址：访问

## 题目及题意分析

### 题目

三步问题。有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶或3阶。实现一种方法，计算小孩有多少种上楼梯的方式。结果可能很大，你需要对结果模1000000007。

**提示:**

1. n范围在[1, 1000000]之间

**示例：**

```
示例1:

 输入：n = 3 
 输出：4
 说明: 有四种走法

示例2:

 输入：n = 5
 输出：13
```

### 题意

- 输入目标高度，输出有几种到达方法
- 一次只能走 1 2 3 个台阶
- 结果需要和 `1000000007` 取模

### 解题思路

**逻辑梳理**

动态递归：

【[分析](https://leetcode-cn.com/problems/three-steps-problem-lcci/solution/4-1-2-3-by-shetia/)】：

1. `n=1` 时
    - [ 1 ] 一种走法
2. `n=2` 时
    - [ 1, 2 ]  [ 2 ] 两种走法
3. `n=3` 时
    - [ 1, 1, 1 ]  [ 1, 2, 1 ]  [ 1, 1, 2 ]  [ 2, 1, 1 ]四种走法
4. `n=4` 时
    - 第一步走  1  时，剩余步数为 4-1 = 3 ，可以分解到 n=3 的子问题上
    - 第一步走  2  时，剩余步数为 4-2 = 2 ，可以分解到 n=2 的子问题上
    - 第一步走  3  时，剩余步数为 4-3 = 1 ，可以分解到 n=1 的子问题上
5. `n=5` 时
    - 第一步走  1  时，剩余步数为 5-1 = 4 ，可以分解到 n=4 的子问题上
    - 第一步走  2  时，剩余步数为 5-2 = 3 ，可以分解到 n=3 的子问题上
    - 第一步走  3  时，剩余步数为 5-3 = 2 ，可以分解到 n=2 的子问题上
6. ....

因此当 n=N 时，走法为 n = N-1、n = N-2、n = N-3的和

**问题**

XXXX

**解决**

XXXX

**逻辑重新梳理**

XXX

## 代码实现

**失败代码**

```tsx
function waysToStep(n: number): number {
    let dp = [0, 1, 2, 4];

    for(let i=4;i<=n;i++){
        dp[i] = dp[i-1] + dp[i-2] + dp[i-3];
    }

    return dp[n] % 1000000007;
};
```

分析：这里一开始想法是直接对结果求模，结果解答失败。实际应该是在每一次计算后都要求一次模，因为后续的结果是需要使用前面的结果来计算的，一个位置的数精度不准确，后续的数都不准确了。

**正确代码**

```tsx
function waysToStep(n: number): number {
    let dp = [0, 1, 2, 4];

    for(let i=4;i<=n;i++){
        dp[i] = (dp[i-1] + dp[i-2] + dp[i-3]) % 1000000007;
    }

    return dp[n];
};
```

**代码优化**

代码只使用到了最近的三个元素的值，其他元素使用一次后就会被丢弃，因此可以缩减使用的空间大小。

```tsx
function waysToStep(n: number): number {
    let num1 = 1;
    let num2 = 2;
    let num3 = 4;
    let temp = 0;

    for(let i=4;i<=n;i++){
        temp = (num1 + num2 + num3) % 1000000007;

        num1 = num2;
        num2 = num3;
        num3 = temp;
    }

    return n < 3 ? n: num3;
};
```

## 总结：

一开始怎么也没有想明白，动态递归是怎么判断的。之前的爬楼梯写的也是云里雾里的。趁着假期用IPAD一笔一笔的分析了一下，才弄清楚。

动态递归就是把大问题拆成小问题，在寻找应该如何构建联系。