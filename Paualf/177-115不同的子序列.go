给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。
字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，"ACE" 是 "ABCDE" 的一个子序列，而 "AEC" 不是）
题目数据保证答案符合 32 位带符号整数范围。
示例 1：
输入：s = "rabbbit", t = "rabbit"
输出：3
解释：
如下图所示, 有 3 种可以从 s 中得到 "rabbit" 的方案。
rabbbit
rabbbit
rabbbit
示例 2：
输入：s = "babgbag", t = "bag"
输出：5
解释：
如下图所示, 有 5 种可以从 s 中得到 "bag" 的方案。 
babgbag
babgbag
babgbag
babgbag
babgbag
 
提示：
0 <= s.length, t.length <= 1000
s 和 t 由英文字母组成

1. Clarification:
        朴素法：
            枚举s的所有子序列的可能性，然后看t出现了多少次
        我想到是不是从 s -> t 的可能发生的次数哈，这样不就是编辑距离了么？
        好像不太对。。。
        动态规划
 r  a  b  b  i  t
          1 0  0  0  0  0 0    
       r  1  1  0  0  0  0 0                 
       a  1  1  1  0  0  0  0  
       b  1  1  1  1   0  0  0    
       b  1  1  1  2  1   0  0
       b  1  1  1  3  3  0   0    
       i   1  1   1 3  3  3   0  
       t   1  1  1  3  3  3   3       
        1. dp定义
        dp[i][j]: s[0-i-1],t[0-j-1] 的最长公共子序列
        想了下好像最长公共子序列不太行。。。

2. 看题解：
看了官方的题解，从后往前遍历
又看了代码随想录的题解，从前往后遍历，一开始我一位从前往后不太行，想不通，还是自己没想通，和题目没啥大关系

1.  确定 dp数组 (dp table) 以及下标的含义
dp[i][j]: 以 i-1为结尾的s子序列中出现以j-1为结尾的个数为dp[i][j]

2. 确定递推公式
分析两种情况
s[i-1] 与 t[j-1] 相等 or
s[i-1] 与 t[j-1] 不相等
一部分使用 s[i-1] 来匹配，那么个数为 dp[i-1][j-1]
一部分是不用s[i-1] 来匹配，个数为 dp[i-1][j]
为什么不用 s[i-1] 来匹配，因为s[i-1] 对应的字母可能有多个哈，所以不一定一定要用 i - 1 哈
所以当 s[i-1] 与 t[j-1] 相等时：dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]
当 s[i-1] 与 t[j-1] 不相等时: dp[i][j] = dp[i-1][j]

3. dp数组如何初始化
dp[i][j] = dp[i-1][j-1] + dp[i-1][j] 和 dp[i][j] = dp[i-1][j]
dp[i][0] 表示：以i-1为结尾的s可以随便删除元素，出现空字符串的个数
dp[i][0] = 1,因为是把以 i -1 为结尾的s，删除所有元素，出现空字符串个数是1
dp[0][j]: 空字符串s可以随便删除元素，出现以j-1为结尾的字符串t的个数
dp[0][j]一定都是0，s如何如何也变不成t
dp[0][0] 应该是 1,空字符串s，可以删除0个元素，变成空字符串t

4. 初始化方向
从上到下

5. case by case

func numDistinct(s string, t string) int {
    m,n := len(s),len(t)
    if n > m {
        return 0
    }
    dp := make([][]int, m + 1)
    for i := 0;i < m + 1;i ++ {
        dp[i] = make([]int, n + 1)
    }
    for i := 0;i < m + 1;i++ {
        dp[i][0] = 1
    }
    for j := 1;j < n + 1;j++ {
        dp[0][j] = 0
    }
    for i := 1;i < m + 1;i++ {
        for j := 1;j < n + 1;j++ {
            if s[i-1] == t[j-1] {
                dp[i][j] = dp[i-1][j-1] + dp[i-1][j]
            }else {
                dp[i][j] = dp[i-1][j]
            }
        }
    }
    return dp[m][n]
}

3. 复杂度分析：
时间复杂度：O(n * m)
空间复杂度：O(n)

4. 总结：
4.1：看到dp数组初始化的时候，心中一下子发现dp是真的难，难的是在于每个状态都要明确，完全不能凭感觉，代码量不是很多，但是里面的逻辑和分析都是确定的，唯一的，错一点这些都会出错的

4.2: 学习规划的时候越来越发现，真正难的是把每一个步骤给写清楚和定义清楚而不是上来就写代码，如果思路是正确的，然后再去写代码的话很快就写出来了
