/*
647. 回文子串
给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

 

示例 1：

输入："abc"
输出：3
解释：三个回文子串: "a", "b", "c"
示例 2：

输入："aaa"
输出：6
解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"
 

提示：

输入的字符串长度不会超过 1000 。
*/

/*
    思路：这一题又跑偏了。
    我觉得问题出在dp的意义定位偏了
    一开始认为dp[i][j]指从i~j中有几个回文串。
    一看题解，回文串的联系在于，如果头尾相等，则头尾各往里缩进一位，查看缩进后的字符串是否是回文串
    故dp[i][j]可用来标记该字符串是否为回文串
    2.状态转移方程
    只记录头尾相等的情况，有点双指针的感觉
    1.如果切割出的字符串长度<=1,即为单个元素，是回文串。result+=1,dp[i][j]=true
    2.长度>1,则开始头尾缩进，如果dp[i+1][j-1]是回文串，同样result+=1,dp[i][j]=true
    if(s[i]==s[j]){
        if(j-i<=1)
        {
            result+=1
            dp[i][j]=true
        }
        else if(dp[i+1][j-1]){
            result+=1
            dp[i][j]=true
        }
    }
    3.初始化
    dp[i][j]初始化为0
    4.遍历顺序
    如果思路不是那么确定，可以根据状态方程推。要判断dp[i+1][j-1]，说明，i需要从大到小，j需要从小到大。同时i,j的距离需要慢慢拉开，首先确认单个字符是回文串，因此j起始位置应该为i.
    5.举例

*/

var countSubstrings = function(s) {
    let len=s.length
    let dp=Array.from(Array(len+1),()=>Array(len+1).fill(0))
    let result=0
    for(let i=len-1;i>=0;i--){
        for(let j=i;j<=len;j++){
            if(s[i]==s[j]){
                //可合并，减少代码量
                if(j-i<=1){
                    result++;
                     dp[i][j]=true
                }
                else if(dp[i+1][j-1]){
                    result++;
                    dp[i][j]=true;
                }

            }
        }
    }
    return result
};
/*
    时间复杂度：O(N^2)
    空间复杂度：O(N^2)
*/

/*
    思考:使用动态规划，或者说定位dp的含义，还是要去思考前后可递推过程中的联系。感觉学完动态规划，回过头看这道题，理解更深了。

*/